import json
import logging
import uuid

from core.celery_app import celery_app
from django.db import transaction
from messaging.constants import PersistChatEntry
from realtime.utils import send_ws_notification

from .models import ChatHistoryEntry, ResearchWorkflowState

logger = logging.getLogger(__name__)

@celery_app.task(name=PersistChatEntry.name, ignore_result=True)
def persist_chat_entry(event_type: str, payload: dict):
    """
    Celery task to asynchronously persist a single chat message entry
    to the ChatHistoryEntry database table.

    Args:
        session_id: The UUID of the ResearchWorkflowState to link the message to.
        role: The sender's role ('user' or 'system').
        content: The text content of the message.
        name: The specific sender name (e.g., 'Explorer Agent').
        sequence_number: The sequential order of the message within the workflow.

    Returns:
        bool: True if the entry was successfully persisted, False otherwise.
    """
    task = persist_chat_entry
    session_id = payload.get('session_id')
    role = payload.get('role')
    content = payload.get('content')
    name = payload.get('name')
    sequence_number = payload.get('sequence_number')

    try:
        # Look up the ResearchWorkflowState instance
        # Retrieve the workflow state using the provided session_id UUID.
        workflow_state = ResearchWorkflowState.objects.get(session_id=uuid.UUID(session_id))
    except ResearchWorkflowState.DoesNotExist:
        # If the workflow state is not found, log an error and stop the task without retrying.
        logger.error(f"WorkflowState with ID {session_id} not found. Aborting chat persistence.")
        return False
    except Exception as e:
        # Handle other retrieval errors and initiate a retry mechanism.
        logger.warning(f"Error fetching WorkflowState {session_id} before persisting chat: {e}. Retrying in 60s.")
        # Retry the task after 60 seconds
        raise task.retry(exc=e, countdown=60)

    try:
        # Create and save the ChatHistoryEntry instance within an atomic transaction
        with transaction.atomic():
            ChatHistoryEntry.objects.create(
                workflow_state=workflow_state,
                role=role,
                content=content,
                name=name,
                sequence_number=sequence_number,
                # 'id' and 'timestamp' are auto-generated by the model
            )

        logger.info(f"Successfully persisted chat entry for session {session_id}, sequence {sequence_number}.")
        return True

    except Exception as e:
        # Handle persistence errors (e.g., database connection issues) and retry
        logger.error(f"Database error while persisting chat entry for session {session_id}: {e}. Retrying in 120s.")
        # Retry the task after 120 seconds.
        raise task.retry(exc=e, countdown=120)